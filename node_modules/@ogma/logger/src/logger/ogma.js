"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ogma = void 0;
const common_1 = require("@ogma/common");
const styler_1 = require("@ogma/styler");
const fast_safe_stringify_1 = __importDefault(require("fast-safe-stringify"));
const os_1 = require("os");
const interfaces_1 = require("../interfaces");
const utils_1 = require("../utils");
const checkIfHasSpaceRegex = /[^\n]$/;
/**
 * The main logger instance
 */
class Ogma {
    constructor(options) {
        var _a;
        this.cachedContextFormatted = new Map();
        this.skipableTypeofValues = new Map([
            ['number', true],
            ['string', true],
            ['boolean', true],
            ['undefined', true],
        ]);
        this.wrappedValues = {};
        /**
         * An alias for `ogma.verbose`. `FINE` is what is printed as the log level
         */
        this.fine = this.verbose;
        /**
         * An alias for `ogma.info`. `INFO` is what is printed as the log level
         */
        this.log = this.info;
        if (options === null || options === void 0 ? void 0 : options.logLevel) {
            options.logLevel = options.logLevel.toUpperCase();
        }
        options &&
            Object.keys(options)
                .filter((key) => (0, utils_1.isNil)(options[key]))
                .forEach((key) => delete options[key]);
        this.options = Object.assign(Object.assign({}, interfaces_1.OgmaDefaults), options);
        this.jsonPid = Number(process.pid);
        this.pid = this.wrapInBrackets(this.jsonPid.toString()) + ' ';
        this.hostname = (0, os_1.hostname)();
        if ((options === null || options === void 0 ? void 0 : options.logLevel) && common_1.LogLevel[options.logLevel] === undefined) {
            this.options.logLevel = interfaces_1.OgmaDefaults.logLevel;
            this.warn(`Ogma logLevel was set to ${options.logLevel} which does not match a defined logLevel. Falling back to default instead.`);
        }
        if (!this.options.stream.getColorDepth) {
            this.setStreamColorDepth();
        }
        this.application = this.options.application;
        if (!this.options.logApplication) {
            this.application = undefined;
        }
        if (!this.options.logHostname) {
            this.hostname = undefined;
        }
        if (!this.options.logPid) {
            this.pid = '';
            this.jsonPid = undefined;
        }
        this.cachedMasks = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.masks)
            ? new Map(this.options.masks.map((mask) => [mask, true]))
            : undefined;
        this.styler = styler_1.style.child(this.options.stream);
        this.each = this.options.each;
        this.sillyFormattedLevel = this.toColor(common_1.LogLevel.SILLY, common_1.Color.MAGENTA);
        this.verboseFormattedLevel = this.toColor(common_1.LogLevel.VERBOSE, common_1.Color.GREEN);
        this.debugFormattedLevel = this.toColor(common_1.LogLevel.DEBUG, common_1.Color.BLUE);
        this.infoFormattedLevel = this.toColor(common_1.LogLevel.INFO, common_1.Color.CYAN);
        this.warnFormattedLevel = this.toColor(common_1.LogLevel.WARN, common_1.Color.YELLOW);
        this.errorFormattedLevel = this.toColor(common_1.LogLevel.ERROR, common_1.Color.RED);
        this.hostnameFormatted = this.options.logHostname
            ? this.toStreamColor(this.hostname, common_1.Color.MAGENTA) + ' '
            : '';
        this.fatalFormattedLevel = this.styler.redBg.white.underline.apply(this.wrapInBrackets(common_1.LogLevel[common_1.LogLevel.FATAL]));
    }
    setStreamColorDepth() {
        let colorDepthVal;
        if (this.options.color) {
            colorDepthVal = 4;
        }
        if (this.options.color === false) {
            colorDepthVal = 1;
        }
        if (!colorDepthVal && this.options.stream !== process.stdout && process.stdout.getColorDepth) {
            colorDepthVal = process.stdout.getColorDepth();
        }
        this.options.stream.getColorDepth = () => colorDepthVal !== null && colorDepthVal !== void 0 ? colorDepthVal : 1;
    }
    printMessage(message, logLevel, formattedLevel, options) {
        const ogmaPrintOptions = options || {};
        if (logLevel < common_1.LogLevel[this.options.logLevel]) {
            return;
        }
        let logString = '';
        if (this.options.json) {
            logString = this.formatJSON(message, logLevel, ogmaPrintOptions);
        }
        else {
            logString = this.formatStream(message, formattedLevel, ogmaPrintOptions);
        }
        this.options.stream.write(`${logString}\n`);
        if (this.options.verbose && !this.options.json) {
            const { context: _context, application: _application, correlationId: _correlationId } = options, meta = __rest(options, ["context", "application", "correlationId"]);
            const verboseLogString = this.formatStream(meta, formattedLevel, ogmaPrintOptions);
            this.options.stream.write(`${verboseLogString}\n`);
        }
    }
    circularReplacer() {
        const seen = new WeakSet();
        return (key, value) => {
            var _a;
            if ((_a = this.cachedMasks) === null || _a === void 0 ? void 0 : _a.has(key)) {
                return '*'.repeat(value.toString().length);
            }
            if (value === null)
                return value;
            const typeofValue = typeof value;
            if (this.skipableTypeofValues.has(typeofValue))
                return value;
            if (typeofValue === 'bigint') {
                return this.wrapInBrackets(`BigInt: ${value.toString()}`);
            }
            if (typeofValue === 'symbol') {
                return this.wrapInBrackets(`Symbol: ${value.description}`);
            }
            if (typeofValue === 'function') {
                return this.wrapInBrackets(`Function: ${value.name || '(anonymous)'}`);
            }
            if (typeofValue === 'object') {
                if (seen.has(value)) {
                    return this.wrapInBrackets('Circular');
                }
                seen.add(value);
            }
            return value;
        };
    }
    toColor(level, color) {
        const levelString = this.wrapInBrackets(this.options.levelMap[common_1.LogLevel[level]]).padEnd(7);
        return (0, utils_1.colorize)(levelString, color, this.styler, this.options.color);
    }
    wrapInBrackets(valueToBeWrapped) {
        let retVal = this.wrappedValues[valueToBeWrapped];
        if (retVal) {
            return retVal;
        }
        retVal = `[${valueToBeWrapped}]`;
        this.wrappedValues[valueToBeWrapped] = retVal;
        return retVal;
    }
    formatJSON(message, level, _a) {
        var { application = this.application, correlationId, context = this.options.context } = _a, meta = __rest(_a, ["application", "correlationId", "context"]);
        const mappedLevel = this.asString(this.options.levelMap[common_1.LogLevel[level]]);
        let fastJson = `{"time":${Date.now()},`;
        fastJson += `"hostname":${this.asString(this.hostname)},`;
        fastJson += `"pid":${this.jsonPid},`;
        fastJson += `"ool":${this.asString(common_1.LogLevel[level])},`;
        fastJson += `"level":${mappedLevel},`;
        if (application)
            fastJson += `"application":${this.asString(application)},`;
        if (correlationId)
            fastJson += `"correlationId":${this.asString(correlationId)},`;
        if (context)
            fastJson += `"context":${this.asString(context)},`;
        if (meta && Object.keys(meta).length > 0)
            fastJson += `"meta":${(0, fast_safe_stringify_1.default)(meta)},`;
        if (this.options.levelKey)
            fastJson += `"${this.options.levelKey}":${mappedLevel},`;
        if (typeof message === 'object')
            fastJson += `"message":${(0, fast_safe_stringify_1.default)(message, this.circularReplacer())}`;
        else
            fastJson += `"message":${this.asString(message.toString())}`;
        fastJson += '}';
        return fastJson;
    }
    // thanks pinojs, ref: https://github.com/pinojs/pino/blob/master/lib/tools.js#L67
    // magically escape strings for json
    // relying on their charCodeAt
    // everything below 32 needs JSON.stringify()
    // 34 and 92 happens all the time, so we
    // have a fast case for them
    asString(str) {
        let result = '';
        let last = 0;
        let found = false;
        let point = 255;
        const l = str.length;
        if (l > 100) {
            return JSON.stringify(str);
        }
        for (let i = 0; i < l && point >= 32; i++) {
            point = str.charCodeAt(i);
            if (point === 34 || point === 92) {
                result += str.slice(last, i) + '\\';
                last = i;
                found = true;
            }
        }
        if (!found) {
            result = str;
        }
        else {
            result += str.slice(last);
        }
        return point < 32 ? JSON.stringify(str) : '"' + result + '"';
    }
    stringifyObject(message, prependNewline = true, addSpace = false, skipRegex = false) {
        let result = message;
        if (typeof message === 'object' && !(message instanceof Error)) {
            result = `${prependNewline ? '\n' : ''}${(0, fast_safe_stringify_1.default)(message, this.circularReplacer(), 2)}`;
        }
        if (skipRegex)
            return `${result}`;
        return `${result}${checkIfHasSpaceRegex.test(result) && addSpace ? ' ' : ''}`;
    }
    formatStream(message, formattedLevel, { application = '', correlationId = '', context = '', each = this.each }) {
        if (Array.isArray(message) && each) {
            const messages = message;
            for (let i = 0; i < messages.length; i++) {
                message += this.stringifyObject(messages[i], i === 0, i + 1 < messages.length);
            }
        }
        else {
            message = this.stringifyObject(message, true, false, true);
        }
        const logContext = this.toStreamColor(context || this.options.context, common_1.Color.CYAN);
        const logCorrelationId = correlationId ? this.wrapInBrackets(correlationId) : '';
        const timestamp = this.wrapInBrackets(this.getTimestamp());
        const applicationName = this.application
            ? this.toStreamColor(application || this.application, common_1.Color.YELLOW) + ' '
            : '';
        return `${timestamp} ${formattedLevel} ${this.hostnameFormatted}${applicationName}${this.pid}${logCorrelationId} ${logContext} ${message}`;
    }
    toStreamColor(value, color) {
        if (!value) {
            return '';
        }
        if (this.cachedContextFormatted.has(value) && this.cachedContextFormatted.get(value).has(color))
            return this.cachedContextFormatted.get(value).get(color);
        if (!this.cachedContextFormatted.has(value))
            this.cachedContextFormatted.set(value, new Map());
        const cachedValue = (0, utils_1.colorize)(this.wrapInBrackets(value), color, this.styler, this.options.color);
        this.cachedContextFormatted.get(value).set(color, cachedValue);
        return cachedValue;
    }
    getTimestamp() {
        return new Date().toISOString();
    }
    /**
     * Make a log at the least important level possible. Could be fun for Easter Eggs if you like adding those in.
     * Prints the level in a magenta color
     * @param message what to log
     * @param meta any additional information you want to add
     */
    silly(message, meta) {
        this.printMessage(message, common_1.LogLevel.SILLY, this.sillyFormattedLevel, meta);
    }
    /**
     * Make a log at the `fine` or `verbose` level. Great for adding in some nitty gritty details.
     * Prints the level in a green color
     * @param message what to log
     * @param meta any additional information you want to add
     */
    verbose(message, meta) {
        this.printMessage(message, common_1.LogLevel.VERBOSE, this.verboseFormattedLevel, meta);
    }
    /**
     * Make a log at the `debug` level. Good for quick messages while debugging that shouldn't make it to production.
     * Prints the level in a blue color
     * @param message what to log
     * @param meta any additional information you want to add
     */
    debug(message, meta) {
        this.printMessage(message, common_1.LogLevel.DEBUG, this.debugFormattedLevel, meta);
    }
    /**
     * Makes a log at the `info` level. This is where most of the logging is done generally.
     * Prints the level in a cyan color
     * @param message what to log
     * @param meta any additional information you want to add
     */
    info(message, meta) {
        this.printMessage(message, common_1.LogLevel.INFO, this.infoFormattedLevel, meta);
    }
    /**
     * Makes a log at the `info` level. This is where most of the logging is done generally.
     * Prints the level in a cyan color
     * @param message what to log
     * @param meta any additional information you want to add
     */
    warn(message, meta) {
        this.printMessage(message, common_1.LogLevel.WARN, this.warnFormattedLevel, meta);
    }
    /**
     * Makes a log at the `info` level. This is where most of the logging is done generally.
     * Prints the level in a cyan color
     * @param message what to log
     * @param meta any additional information you want to add
     */
    error(message, meta) {
        this.printMessage(message, common_1.LogLevel.ERROR, this.errorFormattedLevel, meta);
    }
    /**
     * Makes a log at the `fatal` level. This is for mission critical problems. Usually if a `fatal` log is made, someone should be getting a call at 3AM.
     * Prints the level in a red background with white underline and lettering
     * Prints the level in a cyan color
     * @param message what to log
     * @param meta any additional information you want to add
     */
    fatal(message, meta) {
        this.printMessage(message, common_1.LogLevel.FATAL, this.fatalFormattedLevel, meta);
    }
    /**
     * Splits up the error between it's name, message, and stack.
     * The name is logged at the `error` level,
     * the message at the `warn` level,
     * and the stack trace at the `verbose` level.
     * @param error The error to print
     * @param meta any additional information you want to add
     */
    printError(error, meta) {
        this.error(error.name, meta);
        this.warn(error.message, meta);
        this.verbose('\n' + error.stack, meta);
    }
}
exports.Ogma = Ogma;
