"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = exports.LogAll = exports.Log = exports.OgmaLoggerRequestScoped = exports.OgmaLogger = void 0;
const common_1 = require("@nestjs/common");
const rxjs_1 = require("rxjs");
const ogma_constants_1 = require("../ogma.constants");
const ogma_provider_1 = require("../ogma.provider");
const OgmaLogger = (topic) => (0, common_1.Inject)((0, ogma_provider_1.createProviderToken)(typeof topic === 'function' ? topic.name : topic));
exports.OgmaLogger = OgmaLogger;
const OgmaLoggerRequestScoped = (topic) => (0, common_1.Inject)((0, ogma_provider_1.createRequestScopedProviderToken)(typeof topic === 'function' ? topic.name : topic));
exports.OgmaLoggerRequestScoped = OgmaLoggerRequestScoped;
const logEnd = ({ context, method }, logger, startTime) => {
    const timing = Date.now() - startTime;
    logger.trace(`End ${method} - ${timing}ms`, { context });
};
const Log = (loggerProperty = 'logger') => (target, propertyKey, descriptor) => {
    const impl = descriptor.value;
    descriptor.value = function (...args) {
        const start = Date.now();
        const method = propertyKey.toString();
        const logger = this[loggerProperty];
        const context = `${target.constructor.name}#${method}`;
        logger.trace(`Start ${method}`, { context });
        let result = impl.apply(this, args);
        if (result.then) {
            result.finally(() => {
                logEnd({ context, method }, logger, start);
            });
        }
        else if ((0, rxjs_1.isObservable)(result)) {
            /**
             * By using `result.pipe` here we are changing the reference to `result` and as such
             * we need to re-assign the `result` back to itself so that the new pipe will be ran
             * with the original observable
             */
            result = result.pipe((0, rxjs_1.tap)({ complete: () => logEnd({ context, method }, logger, start) }));
        }
        else {
            logEnd({ context, method }, logger, start);
        }
        return result;
    };
    return descriptor;
};
exports.Log = Log;
const LogAll = (loggerProperty = 'logger') => (target) => {
    const allKeys = Reflect.ownKeys(target.prototype);
    const keys = allKeys.filter((key) => key !== 'constructor');
    for (const key of keys) {
        const logRet = (0, exports.Log)(loggerProperty)(target.prototype, key, Reflect.getOwnPropertyDescriptor(target.prototype, key));
        if (logRet) {
            target.prototype[key] = logRet.value;
        }
    }
    return target;
};
exports.LogAll = LogAll;
const Parser = (type) => (target) => {
    Reflect.defineMetadata(ogma_constants_1.OGMA_CONTEXT_PARSER, type, target);
    return target;
};
exports.Parser = Parser;
