"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OgmaInterceptor = void 0;
const common_1 = require("@nestjs/common");
const core_1 = require("@nestjs/core");
const operators_1 = require("rxjs/operators");
const ogma_constants_1 = require("../ogma.constants");
const ogma_service_1 = require("../ogma.service");
const providers_1 = require("./providers");
/**
 * An interceptor to handle logging for just about any kind of request that Nest can handle
 */
let OgmaInterceptor = exports.OgmaInterceptor = class OgmaInterceptor {
    constructor(service, delegate, reflector) {
        this.service = service;
        this.delegate = delegate;
        this.reflector = reflector;
        const ogmaOptions = this.service.ogma.options;
        this.json = ogmaOptions.json;
        this.color = ogmaOptions.color;
    }
    intercept(context, next) {
        const startTime = Date.now();
        const options = { json: this.json, color: this.color };
        const correlationId = this.generateRequestId(context);
        this.delegate.setRequestId(context, correlationId);
        return next.handle().pipe(this.rxJsLogTap({ context, startTime, options, correlationId }));
    }
    rxJsLogTap(meta) {
        return (0, operators_1.tap)({
            next: (data) => {
                const info = Object.assign(Object.assign({}, meta), { data });
                this.shouldLogAndDoIt('Success', info);
            },
            error: (err) => {
                const info = Object.assign(Object.assign({}, meta), { data: err });
                this.shouldLogAndDoIt('Error', info);
            },
        });
    }
    shouldLogAndDoIt(method, { context, startTime, data, correlationId, options }) {
        const callMethod = `getContext${method}String`;
        if (!this.shouldSkip(context)) {
            const { meta, log: logObject } = this.delegate[callMethod](data, context, startTime, options);
            this.log(logObject, context, correlationId);
            if (meta) {
                this.log(meta, context, correlationId);
            }
        }
    }
    /**
     * A method to determine if a request should be logged or not. This is determined by several factors:
     * 1) If `@OgmaSkip()` decorator is present on the class or the handler, the request should not be logged
     * 2) If the request is from a GQL subscription, it should not be logged
     * 3) if the request is for a contextType that does not have a parser installed and passed in the options, it should not be logged
     * @param context the execution context
     * @returns a boolean on if the request should not be logged
     */
    shouldSkip(context) {
        var _a, _b;
        const decoratorSkip = this.reflector.get(ogma_constants_1.OGMA_INTERCEPTOR_SKIP, context.getClass()) ||
            this.reflector.get(ogma_constants_1.OGMA_INTERCEPTOR_SKIP, context.getHandler());
        if (decoratorSkip) {
            return true;
        }
        if (context.getType() === 'graphql') {
            return ((_b = (_a = context.getArgByIndex(3)) === null || _a === void 0 ? void 0 : _a.operation) === null || _b === void 0 ? void 0 : _b.operation) === 'subscription';
        }
    }
    log(logObject, context, correlationId) {
        this.service.info(logObject, {
            context: `${context.getClass().name}#${context.getHandler().name}`,
            correlationId,
        });
    }
    /**
     * A method to generate a new correlationId on each request
     * @param _context The execution context object
     * @returns a string that represents the correlationId
     */
    generateRequestId(_context) {
        const time = Date.now().toString();
        const randomNumbers = Math.floor(Math.random() * (1000 - 100) + 100);
        return time + randomNumbers.toString();
    }
};
exports.OgmaInterceptor = OgmaInterceptor = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [ogma_service_1.OgmaService,
        providers_1.DelegatorService,
        core_1.Reflector])
], OgmaInterceptor);
