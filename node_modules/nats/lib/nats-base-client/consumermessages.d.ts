import { QueuedIterator, QueuedIteratorImpl } from "./queued_iterator";
import type { ConsumeOptions, ConsumerMessages, ConsumerStatus, FetchOptions, PullOptions, Subscription } from "./types";
import { ConsumerCallbackFn, ConsumerDebugEvents, ConsumerEvents, JsMsg, MsgHdrs, PullConsumerOptions } from "./types";
import { IdleHeartbeat } from "./idleheartbeat";
import { PullConsumerImpl } from "./consumer";
import { Timeout } from "./util";
export declare class PullConsumerMessagesImpl extends QueuedIteratorImpl<JsMsg> implements ConsumerMessages {
    consumer: PullConsumerImpl;
    opts: Record<string, number>;
    sub: Subscription;
    monitor: IdleHeartbeat | null;
    pending: {
        msgs: number;
        bytes: number;
        requests: number;
    };
    inbox: string;
    refilling: boolean;
    stack: string;
    pong: Promise<void> | null;
    callback: ConsumerCallbackFn | null;
    timeout: Timeout<unknown> | null;
    cleanupHandler?: () => void;
    listeners: QueuedIterator<ConsumerStatus>[];
    constructor(c: PullConsumerImpl, opts: ConsumeOptions | FetchOptions, refilling?: boolean);
    _push(r: JsMsg): void;
    notify(type: ConsumerEvents | ConsumerDebugEvents, data: unknown): void;
    resetPending(): Promise<boolean>;
    pull(opts: Partial<PullOptions>): void;
    pullOptions(): Partial<PullOptions>;
    parseDiscard(headers?: MsgHdrs): {
        msgsLeft: number;
        bytesLeft: number;
    };
    trackTimeout(t: Timeout<unknown>): void;
    close(): Promise<void>;
    closed(): Promise<void>;
    clearTimers(): void;
    setCleanupHandler(fn?: () => void): void;
    stop(err?: Error): void;
    parseOptions(opts: PullConsumerOptions, refilling?: boolean): Record<string, number>;
    status(): Promise<AsyncIterable<ConsumerStatus>>;
}
export declare class OrderedConsumerMessages extends QueuedIteratorImpl<JsMsg> implements ConsumerMessages {
    src: PullConsumerMessagesImpl;
    constructor();
    setSource(src: PullConsumerMessagesImpl): void;
    stop(err?: Error): void;
    close(): Promise<void>;
    status(): Promise<AsyncIterable<ConsumerStatus>>;
}
