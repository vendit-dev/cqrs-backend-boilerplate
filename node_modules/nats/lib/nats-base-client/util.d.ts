import { QueuedIterator } from "./queued_iterator";
export declare const CR_LF = "\r\n";
export declare const CR_LF_LEN: number;
export declare const CRLF: Uint8Array;
export declare const CR: number;
export declare const LF: number;
export type ValueResult<T> = {
    isError: false;
    value: T;
};
export type ErrorResult = {
    isError: true;
    error: Error;
};
/**
 * Result is a value that may have resulted in an error.
 */
export type Result<T> = ValueResult<T> | ErrorResult;
export declare function isUint8Array(a: unknown): boolean;
export declare function protoLen(ba: Uint8Array): number;
export declare function extractProtocolMessage(a: Uint8Array): string;
export declare function extend(a: any, ...b: any[]): any;
export interface Pending {
    pending: number;
    write: (c: number) => void;
    wrote: (c: number) => void;
    err: (err: Error) => void;
    close: () => void;
    promise: () => Promise<any>;
    resolved: boolean;
    done: boolean;
}
export declare function render(frame: Uint8Array): string;
export interface Timeout<T> extends Promise<T> {
    cancel: () => void;
}
export declare function timeout<T>(ms: number): Timeout<T>;
export declare function delay(ms?: number): Promise<void>;
export declare function deadline<T>(p: Promise<T>, millis?: number): Promise<T>;
export interface Deferred<T> extends Promise<T> {
    /**
     * Resolves the Deferred to a value T
     * @param value
     */
    resolve: (value?: T | PromiseLike<T>) => void;
    /**
     * Rejects the Deferred
     * @param reason
     */
    reject: (reason?: any) => void;
}
/**
 * Returns a Promise that has a resolve/reject methods that can
 * be used to resolve and defer the Deferred.
 */
export declare function deferred<T>(): Deferred<T>;
export declare function debugDeferred<T>(): Deferred<T>;
export declare function shuffle<T>(a: T[]): T[];
export declare function collect<T>(iter: QueuedIterator<T>): Promise<T[]>;
export declare class Perf {
    timers: Map<string, number>;
    measures: Map<string, number>;
    constructor();
    mark(key: string): void;
    measure(key: string, startKey: string, endKey: string): void;
    getEntries(): {
        name: string;
        duration: number;
    }[];
}
export declare class SimpleMutex {
    max: number;
    current: number;
    waiting: Deferred<void>[];
    /**
     * @param max number of concurrent operations
     */
    constructor(max?: number);
    /**
     * Returns a promise that resolves when the mutex is acquired
     */
    lock(): Promise<void>;
    /**
     * Release an acquired mutex - must be called
     */
    unlock(): void;
}
