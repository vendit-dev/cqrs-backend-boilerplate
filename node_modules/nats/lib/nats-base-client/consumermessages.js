"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrderedConsumerMessages = exports.PullConsumerMessagesImpl = void 0;
/*
 * Copyright 2022-2023 The NATS Authors
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const queued_iterator_1 = require("./queued_iterator");
const types_1 = require("./types");
const idleheartbeat_1 = require("./idleheartbeat");
const protocol_1 = require("./protocol");
const jsutil_1 = require("./jsutil");
const jsmsg_1 = require("./jsmsg");
class PullConsumerMessagesImpl extends queued_iterator_1.QueuedIteratorImpl {
    // callback: ConsumerCallbackFn;
    constructor(c, opts, refilling = false) {
        super();
        this.consumer = c;
        this.opts = this.parseOptions(opts, refilling);
        this.callback = opts.callback || null;
        this.noIterator = typeof this.callback === "function";
        this.monitor = null;
        this.pong = null;
        this.pending = { msgs: 0, bytes: 0, requests: 0 };
        this.refilling = refilling;
        this.stack = new Error().stack.split("\n").slice(1).join("\n");
        this.timeout = null;
        this.inbox = (0, protocol_1.createInbox)();
        this.listeners = [];
        const { max_messages, max_bytes, idle_heartbeat, threshold_bytes, threshold_messages, } = this.opts;
        // ordered consumer requires the ability to reset the
        // source pull consumer, if promise is registered and
        // close is called, the pull consumer will emit a close
        // which will close the ordered consumer, by registering
        // the close with a handler, we can replace it.
        this.closed().then(() => {
            if (this.cleanupHandler) {
                try {
                    this.cleanupHandler();
                }
                catch (_err) {
                    // nothing
                }
            }
        });
        const { sub } = this;
        if (sub) {
            sub.unsubscribe();
        }
        this.sub = c.api.nc.subscribe(this.inbox, {
            callback: (err, msg) => {
                var _a, _b, _c, _d;
                if (err) {
                    // this is possibly only a permissions error which means
                    // that the server rejected (eliminating the sub)
                    // or the client never had permissions to begin with
                    // so this is terminal
                    this.stop();
                    return;
                }
                (_a = this.monitor) === null || _a === void 0 ? void 0 : _a.work();
                const isProtocol = msg.subject === this.inbox;
                if (isProtocol) {
                    if ((0, jsutil_1.isHeartbeatMsg)(msg)) {
                        return;
                    }
                    const code = (_b = msg.headers) === null || _b === void 0 ? void 0 : _b.code;
                    const description = ((_d = (_c = msg.headers) === null || _c === void 0 ? void 0 : _c.description) === null || _d === void 0 ? void 0 : _d.toLowerCase()) ||
                        "unknown";
                    const { msgsLeft, bytesLeft } = this.parseDiscard(msg.headers);
                    if (msgsLeft > 0 || bytesLeft > 0) {
                        this.pending.msgs -= msgsLeft;
                        this.pending.bytes -= bytesLeft;
                        this.pending.requests--;
                        this.notify(types_1.ConsumerDebugEvents.Discard, { msgsLeft, bytesLeft });
                    }
                    else {
                        // FIXME: 408 can be a Timeout or bad request,
                        //  or it can be sent if a nowait request was
                        //  sent when other waiting requests are pending
                        //  "Requests Pending"
                        // FIXME: 400 bad request Invalid Heartbeat or Unmarshalling Fails
                        //  these are real bad values - so this is bad request
                        //  fail on this
                        const toErr = () => {
                            const err = new types_1.NatsError(description, `${code}`);
                            err.stack += `\n\n${this.stack}`;
                            return err;
                        };
                        // we got a bad request - no progress here
                        if (code === 400) {
                            const error = toErr();
                            //@ts-ignore: fn
                            this._push(() => {
                                this.stop(error);
                            });
                        }
                        else if (code === 409 && description === "consumer deleted") {
                            const error = toErr();
                            this.stop(error);
                        }
                        else {
                            this.notify(types_1.ConsumerDebugEvents.DebugEvent, `${code} ${description}`);
                        }
                    }
                }
                else {
                    // push the user message
                    this._push((0, jsmsg_1.toJsMsg)(msg));
                    this.received++;
                    if (this.pending.msgs) {
                        this.pending.msgs--;
                    }
                    if (this.pending.bytes) {
                        this.pending.bytes -= msg.size();
                    }
                }
                // if we don't have pending bytes/messages we are done or starving
                if (this.pending.msgs === 0 && this.pending.bytes === 0) {
                    this.pending.requests = 0;
                }
                if (this.refilling) {
                    // FIXME: this could result in  1/4 = 0
                    if ((max_messages &&
                        this.pending.msgs <= threshold_messages) ||
                        (max_bytes && this.pending.bytes <= threshold_bytes)) {
                        const batch = this.pullOptions();
                        // @ts-ignore: we are pushing the pull fn
                        this.pull(batch);
                    }
                }
                else if (this.pending.requests === 0) {
                    // @ts-ignore: we are pushing the pull fn
                    this._push(() => {
                        this.stop();
                    });
                }
            },
        });
        if (idle_heartbeat) {
            this.monitor = new idleheartbeat_1.IdleHeartbeat(idle_heartbeat, (data) => {
                // for the pull consumer - missing heartbeats may be corrected
                // on the next pull etc - the only assumption here is we should
                // reset and check if the consumer was deleted from under us
                this.notify(types_1.ConsumerEvents.HeartbeatsMissed, data);
                this.resetPending()
                    .then(() => {
                })
                    .catch(() => {
                });
                return false;
            }, { maxOut: 2 });
        }
        // now if we disconnect, the consumer could be gone
        // or we were slow consumer'ed by the server
        (() => __awaiter(this, void 0, void 0, function* () {
            var _a, e_1, _b, _c;
            var _d;
            try {
                for (var _e = true, _f = __asyncValues(c.api.nc.status()), _g; _g = yield _f.next(), _a = _g.done, !_a;) {
                    _c = _g.value;
                    _e = false;
                    try {
                        const s = _c;
                        switch (s.type) {
                            case types_1.Events.Disconnect:
                                // don't spam hb errors if we are disconnected
                                // @ts-ignore: optional chaining
                                (_d = this.monitor) === null || _d === void 0 ? void 0 : _d.cancel();
                                break;
                            case types_1.Events.Reconnect:
                                // do some sanity checks and reset
                                // if that works resume the monitor
                                this.resetPending()
                                    .then((ok) => {
                                    var _a;
                                    if (ok) {
                                        // @ts-ignore: optional chaining
                                        (_a = this.monitor) === null || _a === void 0 ? void 0 : _a.restart();
                                    }
                                })
                                    .catch(() => {
                                    // ignored - this should have fired elsewhere
                                });
                                break;
                            default:
                            // ignored
                        }
                    }
                    finally {
                        _e = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }))();
        // this is the initial pull
        this.pull(this.pullOptions());
    }
    _push(r) {
        if (!this.callback) {
            super.push(r);
        }
        else {
            const fn = typeof r === "function" ? r : null;
            try {
                if (!fn) {
                    this.callback(r);
                }
                else {
                    fn();
                }
            }
            catch (err) {
                this.stop(err);
            }
        }
    }
    notify(type, data) {
        if (this.listeners.length > 0) {
            (() => {
                this.listeners.forEach((l) => {
                    if (!l.done) {
                        l.push({ type, data });
                    }
                });
            })();
        }
    }
    resetPending() {
        // check we exist
        return this.consumer.info()
            .then((_ci) => {
            // we exist, so effectively any pending state is gone
            // so reset and re-pull
            this.pending.msgs = 0;
            this.pending.bytes = 0;
            this.pending.requests = 0;
            this.pull(this.pullOptions());
            return true;
        })
            .catch((err) => {
            // game over
            if (err.message === "consumer not found") {
                this.stop(err);
            }
            return false;
        });
    }
    pull(opts) {
        var _a, _b;
        this.pending.bytes += (_a = opts.max_bytes) !== null && _a !== void 0 ? _a : 0;
        this.pending.msgs += (_b = opts.batch) !== null && _b !== void 0 ? _b : 0;
        this.pending.requests++;
        const nc = this.consumer.api.nc;
        //@ts-ignore: iterator will pull
        this._push(() => {
            nc.publish(`${this.consumer.api.prefix}.CONSUMER.MSG.NEXT.${this.consumer.stream}.${this.consumer.name}`, this.consumer.api.jc.encode(opts), { reply: this.inbox });
            this.notify(types_1.ConsumerDebugEvents.Next, opts);
        });
    }
    pullOptions() {
        const batch = this.opts.max_messages - this.pending.msgs;
        const max_bytes = this.opts.max_bytes - this.pending.bytes;
        const idle_heartbeat = (0, jsutil_1.nanos)(this.opts.idle_heartbeat);
        const expires = (0, jsutil_1.nanos)(this.opts.expires);
        return { batch, max_bytes, idle_heartbeat, expires };
    }
    parseDiscard(headers) {
        const discard = {
            msgsLeft: 0,
            bytesLeft: 0,
        };
        const msgsLeft = headers === null || headers === void 0 ? void 0 : headers.get("Nats-Pending-Messages");
        if (msgsLeft) {
            discard.msgsLeft = parseInt(msgsLeft);
        }
        const bytesLeft = headers === null || headers === void 0 ? void 0 : headers.get("Nats-Pending-Bytes");
        if (bytesLeft) {
            discard.bytesLeft = parseInt(bytesLeft);
        }
        return discard;
    }
    trackTimeout(t) {
        this.timeout = t;
    }
    close() {
        this.stop();
        return this.iterClosed;
    }
    closed() {
        return this.iterClosed;
    }
    clearTimers() {
        var _a, _b;
        (_a = this.monitor) === null || _a === void 0 ? void 0 : _a.cancel();
        this.monitor = null;
        (_b = this.timeout) === null || _b === void 0 ? void 0 : _b.cancel();
        this.timeout = null;
    }
    setCleanupHandler(fn) {
        this.cleanupHandler = fn;
    }
    stop(err) {
        var _a;
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        this.clearTimers();
        //@ts-ignore: fn
        this._push(() => {
            super.stop(err);
            this.listeners.forEach((n) => {
                n.stop();
            });
        });
    }
    parseOptions(opts, refilling = false) {
        const args = (opts || {});
        args.max_messages = args.max_messages || 0;
        args.max_bytes = args.max_bytes || 0;
        if (args.max_messages !== 0 && args.max_bytes !== 0) {
            throw new Error(`only specify one of max_messages or max_bytes`);
        }
        // we must have at least one limit - default to 100 msgs
        // if they gave bytes but no messages, we will clamp
        // if they gave byte limits, we still need a message limit
        // or the server will send a single message and close the
        // request
        if (args.max_messages === 0) {
            // FIXME: if the server gives end pull completion, then this is not
            //   needed - the client will get 1 message but, we'll know that it
            //   worked - but we'll add a lot of latency, since all requests
            //   will end after one message
            args.max_messages = 100;
        }
        args.expires = args.expires || 30000;
        if (args.expires < 1000) {
            throw new Error("expires should be at least 1000ms");
        }
        // require idle_heartbeat
        args.idle_heartbeat = args.idle_heartbeat || args.expires / 2;
        args.idle_heartbeat = args.idle_heartbeat > 30000
            ? 30000
            : args.idle_heartbeat;
        if (refilling) {
            const minMsgs = Math.round(args.max_messages * .75) || 1;
            args.threshold_messages = args.threshold_messages || minMsgs;
            const minBytes = Math.round(args.max_bytes * .75) || 1;
            args.threshold_bytes = args.threshold_bytes || minBytes;
        }
        return args;
    }
    status() {
        const iter = new queued_iterator_1.QueuedIteratorImpl();
        this.listeners.push(iter);
        return Promise.resolve(iter);
    }
}
exports.PullConsumerMessagesImpl = PullConsumerMessagesImpl;
class OrderedConsumerMessages extends queued_iterator_1.QueuedIteratorImpl {
    constructor() {
        super();
    }
    setSource(src) {
        if (this.src) {
            this.src.setCleanupHandler();
            this.src.stop();
        }
        this.src = src;
        this.src.setCleanupHandler(() => {
            this.close().catch();
        });
    }
    stop(err) {
        var _a;
        (_a = this.src) === null || _a === void 0 ? void 0 : _a.stop(err);
        super.stop(err);
    }
    close() {
        this.stop();
        return this.iterClosed;
    }
    status() {
        return Promise.reject(new Error("ordered consumers don't report consumer status"));
    }
}
exports.OrderedConsumerMessages = OrderedConsumerMessages;
//# sourceMappingURL=consumermessages.js.map