"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrderedPullConsumerImpl = exports.PullConsumerImpl = void 0;
/*
 * Copyright 2022-2023 The NATS Authors
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const types_1 = require("./types");
const util_1 = require("./util");
const consumermessages_1 = require("./consumermessages");
const nuid_1 = require("./nuid");
const jsutil_1 = require("./jsutil");
var PullConsumerType;
(function (PullConsumerType) {
    PullConsumerType[PullConsumerType["Unset"] = -1] = "Unset";
    PullConsumerType[PullConsumerType["Consume"] = 0] = "Consume";
    PullConsumerType[PullConsumerType["Fetch"] = 1] = "Fetch";
})(PullConsumerType || (PullConsumerType = {}));
class PullConsumerImpl {
    constructor(api, info) {
        this.api = api;
        this._info = info;
        this.stream = info.stream_name;
        this.name = info.name;
    }
    consume(opts = {
        max_messages: 100,
        expires: 30000,
    }) {
        return Promise.resolve(new consumermessages_1.PullConsumerMessagesImpl(this, opts, true));
    }
    fetch(opts = {
        max_messages: 100,
        expires: 30000,
    }) {
        const m = new consumermessages_1.PullConsumerMessagesImpl(this, opts, false);
        // FIXME: need some way to pad this correctly
        const to = Math.round(m.opts.expires * 1.05);
        const timer = (0, util_1.timeout)(to);
        m.closed().then(() => {
            timer.cancel();
        });
        timer.catch(() => {
            m.close().catch();
        });
        m.trackTimeout(timer);
        return Promise.resolve(m);
    }
    next(opts = { expires: 30000 }) {
        const d = (0, util_1.deferred)();
        const fopts = opts;
        fopts.max_messages = 1;
        const iter = new consumermessages_1.PullConsumerMessagesImpl(this, fopts, false);
        // FIXME: need some way to pad this correctly
        const to = Math.round(iter.opts.expires * 1.05);
        // watch the messages for heartbeats missed
        if (to >= 60000) {
            (() => __awaiter(this, void 0, void 0, function* () {
                var _a, e_1, _b, _c;
                try {
                    for (var _d = true, _e = __asyncValues(yield iter.status()), _f; _f = yield _e.next(), _a = _f.done, !_a;) {
                        _c = _f.value;
                        _d = false;
                        try {
                            const s = _c;
                            if (s.type === types_1.ConsumerEvents.HeartbeatsMissed &&
                                s.data >= 2) {
                                d.reject(new Error("consumer missed heartbeats"));
                                break;
                            }
                        }
                        finally {
                            _d = true;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }))().catch();
        }
        (() => __awaiter(this, void 0, void 0, function* () {
            var _g, e_2, _h, _j;
            try {
                for (var _k = true, iter_1 = __asyncValues(iter), iter_1_1; iter_1_1 = yield iter_1.next(), _g = iter_1_1.done, !_g;) {
                    _j = iter_1_1.value;
                    _k = false;
                    try {
                        const m = _j;
                        d.resolve(m);
                        break;
                    }
                    finally {
                        _k = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_k && !_g && (_h = iter_1.return)) yield _h.call(iter_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }))().catch();
        const timer = (0, util_1.timeout)(to);
        iter.closed().then(() => {
            d.resolve(null);
            timer.cancel();
        }).catch((err) => {
            d.reject(err);
        });
        timer.catch((_err) => {
            d.resolve(null);
            iter.close().catch();
        });
        iter.trackTimeout(timer);
        return d;
    }
    delete() {
        const { stream_name, name } = this._info;
        return this.api.delete(stream_name, name);
    }
    info(cached = false) {
        if (cached) {
            return Promise.resolve(this._info);
        }
        const { stream_name, name } = this._info;
        return this.api.info(stream_name, name)
            .then((ci) => {
            this._info = ci;
            return this._info;
        });
    }
}
exports.PullConsumerImpl = PullConsumerImpl;
class OrderedPullConsumerImpl {
    constructor(api, stream, opts = {}) {
        this.api = api;
        this.stream = stream;
        this.cursor = { stream_seq: 1, deliver_seq: 0 };
        this.namePrefix = nuid_1.nuid.next();
        this.serial = 0;
        this.currentConsumer = null;
        this.userCallback = null;
        this.iter = null;
        this.type = PullConsumerType.Unset;
        this.consumerOpts = opts;
        // to support a random start sequence we need to update the cursor
        this.startSeq = this.consumerOpts.opt_start_seq || 0;
        this.cursor.stream_seq = this.startSeq > 0 ? this.startSeq - 1 : 0;
    }
    getConsumerOpts(seq) {
        // change the serial - invalidating any callback not
        // matching the serial
        this.serial++;
        const name = `${this.namePrefix}_${this.serial}`;
        seq = seq === 0 ? 1 : seq;
        const config = {
            name,
            deliver_policy: types_1.DeliverPolicy.StartSequence,
            opt_start_seq: seq,
            ack_policy: types_1.AckPolicy.None,
            inactive_threshold: (0, jsutil_1.nanos)(5 * 60 * 1000),
            num_replicas: 1,
        };
        if (Array.isArray(this.consumerOpts.filterSubjects)) {
            config.filter_subjects = this.consumerOpts.filterSubjects;
        }
        if (typeof this.consumerOpts.filterSubjects === "string") {
            config.filter_subject = this.consumerOpts.filterSubjects;
        }
        // this is the initial request - tweak some options
        if (seq === this.startSeq + 1) {
            config.deliver_policy = this.consumerOpts.deliver_policy ||
                types_1.DeliverPolicy.StartSequence;
            if (this.consumerOpts.deliver_policy === types_1.DeliverPolicy.LastPerSubject ||
                this.consumerOpts.deliver_policy === types_1.DeliverPolicy.New ||
                this.consumerOpts.deliver_policy === types_1.DeliverPolicy.Last) {
                delete config.opt_start_seq;
                config.deliver_policy = this.consumerOpts.deliver_policy;
            }
            // this requires a filter subject - we only set if they didn't
            // set anything, and to be pre-2.10 we set it as filter_subject
            if (config.deliver_policy === types_1.DeliverPolicy.LastPerSubject) {
                if (typeof config.filter_subjects === "undefined" &&
                    typeof config.filter_subject === "undefined") {
                    config.filter_subject = ">";
                }
            }
            if (this.consumerOpts.opt_start_time) {
                delete config.opt_start_seq;
                config.deliver_policy = types_1.DeliverPolicy.StartTime;
                config.opt_start_time = this.consumerOpts.opt_start_time;
            }
            if (this.consumerOpts.inactive_threshold) {
                config.inactive_threshold = (0, jsutil_1.nanos)(this.consumerOpts.inactive_threshold);
            }
        }
        return config;
    }
    resetConsumer(seq = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            // try to delete the consumer
            if (this.consumer) {
                // FIXME: this needs to be a standard request option to retry
                while (true) {
                    try {
                        yield this.delete();
                        break;
                    }
                    catch (err) {
                        if (err.message !== "TIMEOUT") {
                            throw err;
                        }
                    }
                }
            }
            seq = seq === 0 ? 1 : seq;
            // reset the consumer sequence as JetStream will renumber from 1
            this.cursor.deliver_seq = 0;
            const config = this.getConsumerOpts(seq);
            let ci;
            // FIXME: replace with general jetstream retry logic
            while (true) {
                try {
                    ci = yield this.api.add(this.stream, config);
                    break;
                }
                catch (err) {
                    if (err.message !== "TIMEOUT") {
                        throw err;
                    }
                }
            }
            return ci;
        });
    }
    internalHandler(serial) {
        // this handler will be noop if the consumer's serial changes
        return (m) => {
            var _a;
            if (this.serial !== serial) {
                return;
            }
            const dseq = m.info.deliverySequence;
            if (dseq !== this.cursor.deliver_seq + 1) {
                this.reset(this.opts);
                return;
            }
            this.cursor.deliver_seq = dseq;
            this.cursor.stream_seq = m.info.streamSequence;
            if (this.userCallback) {
                this.userCallback(m);
            }
            else {
                (_a = this.iter) === null || _a === void 0 ? void 0 : _a.push(m);
            }
        };
    }
    reset(opts = {
        max_messages: 100,
        expires: 30000,
    }, fromFetch = false) {
        return __awaiter(this, void 0, void 0, function* () {
            this.currentConsumer = yield this.resetConsumer(this.cursor.stream_seq + 1);
            if (this.iter === null) {
                this.iter = new consumermessages_1.OrderedConsumerMessages();
            }
            this.consumer = new PullConsumerImpl(this.api, this.currentConsumer);
            const copts = opts;
            copts.callback = this.internalHandler(this.serial);
            let msgs = null;
            if (this.type === PullConsumerType.Fetch && fromFetch) {
                // we only repull if client initiates
                msgs = yield this.consumer.fetch(opts);
            }
            else if (this.type === PullConsumerType.Consume) {
                msgs = yield this.consumer.consume(opts);
            }
            else {
                return Promise.reject("reset called with unset consumer type");
            }
            this.iter.setSource(msgs);
            return this.iter;
        });
    }
    consume(opts = {
        max_messages: 100,
        expires: 30000,
    }) {
        if (this.type === PullConsumerType.Fetch) {
            return Promise.reject(new Error("ordered consumer initialized as fetch"));
        }
        if (this.type === PullConsumerType.Consume) {
            return Promise.reject(new Error("ordered consumer doesn't support concurrent consume"));
        }
        const { callback } = opts;
        if (callback) {
            this.userCallback = callback;
        }
        this.type = PullConsumerType.Consume;
        this.opts = opts;
        return this.reset(opts);
    }
    fetch(opts = { max_messages: 100, expires: 30000 }) {
        var _a;
        if (this.type === PullConsumerType.Consume) {
            return Promise.reject(new Error("ordered consumer already initialized as consume"));
        }
        if (((_a = this.iter) === null || _a === void 0 ? void 0 : _a.done) === false) {
            return Promise.reject(new Error("ordered consumer doesn't support concurrent fetch"));
        }
        //@ts-ignore: allow this for tests - api doesn't use it because
        // iterator close is the user signal that the pull is done.
        const { callback } = opts;
        if (callback) {
            this.userCallback = callback;
        }
        this.type = PullConsumerType.Fetch;
        this.opts = opts;
        this.iter = new consumermessages_1.OrderedConsumerMessages();
        return this.reset(opts, true);
    }
    next(opts = { expires: 30000 }) {
        return __awaiter(this, void 0, void 0, function* () {
            const d = (0, util_1.deferred)();
            const copts = opts;
            copts.max_messages = 1;
            copts.callback = (m) => {
                // we can clobber the callback, because they are not supported
                // except on consume, which will fail when we try to fetch
                this.userCallback = null;
                d.resolve(m);
            };
            const iter = yield this.fetch(copts);
            iter.iterClosed
                .then(() => {
                d.resolve(null);
            })
                .catch((err) => {
                d.reject(err);
            });
            return d;
        });
    }
    delete() {
        if (!this.currentConsumer) {
            return Promise.resolve(false);
        }
        return this.api.delete(this.stream, this.currentConsumer.name)
            .then((tf) => {
            return Promise.resolve(tf);
        })
            .catch((err) => {
            return Promise.reject(err);
        })
            .finally(() => {
            this.currentConsumer = null;
        });
    }
    info(cached) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.currentConsumer == null) {
                this.currentConsumer = yield this.resetConsumer(this.serial);
                return Promise.resolve(this.currentConsumer);
            }
            if (cached && this.currentConsumer) {
                return Promise.resolve(this.currentConsumer);
            }
            return this.api.info(this.stream, this.currentConsumer.name);
        });
    }
}
exports.OrderedPullConsumerImpl = OrderedPullConsumerImpl;
//# sourceMappingURL=consumer.js.map